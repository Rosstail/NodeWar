package fr.rosstail.nodewar.commands.subcommands.admincommands.adminterritorycommands;

import fr.rosstail.nodewar.commands.SubCommand;
import fr.rosstail.nodewar.lang.AdaptMessage;
import fr.rosstail.nodewar.lang.LangManager;
import fr.rosstail.nodewar.lang.LangMessage;
import fr.rosstail.nodewar.territory.eventhandlers.customevents.TerritoryVulnerabilityToggleEvent;
import fr.rosstail.nodewar.territory.zonehandlers.Territory;
import fr.rosstail.nodewar.territory.zonehandlers.WorldTerritoryManager;
import org.bukkit.Bukkit;
import org.bukkit.World;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class AdminTerritoryVulnerabilityCommand extends SubCommand {
    @Override
    public String getName() {
        return "vulnerability";
    }

    @Override
    public String getDescription() {
        return "Set the vulnerability of a territory";
    }

    @Override
    public String getSyntax() {
        return "nodewar admin territory vulnerability [territory] [true/false]";
    }

    @Override
    public String getPermission() {
        return "nodewar.command.admin.territory.vulnerability";
    }

    @Override
    public void perform(CommandSender sender, String[] args) {
        if (!sender.hasPermission(getPermission())) {
            sender.sendMessage(AdaptMessage.adapt(LangManager.getMessage(LangMessage.PERMISSION_DENIED)));
            return;
        }
        if (args.length < 5) {
            sender.sendMessage(AdaptMessage.adapt(LangManager.getMessage(LangMessage.TOO_FEW_ARGUMENTS)));
            return;
        }

        String[] location = args[3].split("/");
        if (location.length < 2) {
            sender.sendMessage("The location is not accurate enough !");
            return;
        }
        String worldName = location[0];
        String vulnerable = args[4];
        World world = Bukkit.getWorld(worldName);
        if (world == null || !WorldTerritoryManager.getUsedWorlds().containsKey(world)) {
            sender.sendMessage(AdaptMessage.worldMessage(world, LangManager.getMessage(LangMessage.WORLD_NOT_USED)));
            return;
        }

        if (!(vulnerable.equalsIgnoreCase("true") || vulnerable.equalsIgnoreCase("false"))) {
            sender.sendMessage(AdaptMessage.adapt(LangManager.getMessage(LangMessage.WRONG_VALUE)));
            return;
        }

        WorldTerritoryManager worldTerritoryManager = WorldTerritoryManager.getUsedWorlds().get(world);
        String territoryName = location[1];
        if (territoryName != null) {
            if (territoryName.equalsIgnoreCase("*")) { //affect every territory
                worldTerritoryManager.getTerritories().forEach((s, territory) -> {
                    TerritoryVulnerabilityToggleEvent toggleEvent = new TerritoryVulnerabilityToggleEvent(territory, Boolean.parseBoolean(vulnerable));
                    Bukkit.getPluginManager().callEvent(toggleEvent);
                });
                sender.sendMessage("All territory are now " + (Boolean.parseBoolean(vulnerable) ? "vulnerable" : "invulnerable") + "whole world " + worldName);
            }
            Map<String, Territory> worldTerritories = worldTerritoryManager.getTerritories();
            if (worldTerritories.containsKey(territoryName)) {
                Territory territory = worldTerritories.get(territoryName);
                TerritoryVulnerabilityToggleEvent toggleEvent = new TerritoryVulnerabilityToggleEvent(territory, Boolean.parseBoolean(vulnerable));
                Bukkit.getPluginManager().callEvent(toggleEvent);
                sender.sendMessage("The territory " + territory.getDisplay() + " is now " + (Boolean.parseBoolean(vulnerable) ? "vulnerable" : "invulnerable"));
            }
        }
    }

    @Override
    public List<String> getSubCommandsArguments(Player sender, String[] args) {
        if (args.length <= 4){
            ArrayList<String> territories = new ArrayList<>();
            WorldTerritoryManager.getUsedWorlds().forEach((world, worldTerritoryManager) -> {
                String[] locationArray = args[3].split("/");
                if (locationArray.length == 0 || world.getName().contains(locationArray[0])) {
                    worldTerritoryManager.getTerritories().forEach((s, territory) -> {
                        if (locationArray.length <= 1 || territory.getName().contains(locationArray[1])) {
                            String territoryString = territory.getWorld().getName() + "/" + s;
                            territories.add(territoryString);
                        }
                    });
                }
            });
            return territories;
        } else if (args.length <= 5) {
            ArrayList<String> booleans = new ArrayList<>();
            booleans.add("True");
            booleans.add("False");
            return booleans;
        }
        return null;
    }
}
